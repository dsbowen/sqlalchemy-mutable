{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SQLAlchemy-Mutable SQLAlchemy-Mutable aspires to be the most powerful and flexible SQLAlchemy database column type. Its features include: Nested mutation tracking Mutation tracking for list and dict Support for storing database models in mutable columns Support for common literals and datetime objects Support for custom mutable classes Support for converting existing classes to mutable classes Compatibility with Flask-SQLAlchemy Installation $ pip install sqlalchemy-mutable Quickstart Setup: from sqlalchemy_mutable import Mutable, MutableType, MutableModelBase, Query from sqlalchemy import create_engine, Column, Integer, String from sqlalchemy.orm import sessionmaker, scoped_session from sqlalchemy.ext.declarative import declarative_base # create a session (standard) engine = create_engine('sqlite:///:memory:') session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() Base = declarative_base() # subclass `MutableModelBase` when creating database models # which may be stored in a `Mutable` object class MyModel(MutableModelBase, Base): __tablename__ = 'mymodel' id = Column(Integer, primary_key=True) greeting = Column(String) # initialize a database column with `MutableType` mutable = Column(MutableType) # add a `query` class attribute initialized with a scoped_session # not necessary for use with Flask-SQLAlchemy query = Query(Session) def __init__(self): # set mutable column to `Mutable` object self.mutable = Mutable() # create the database (standard) Base.metadata.create_all(engine) Examples: model = MyModel() session.add(model) session.commit() # nested mutable objects model.mutable.nested_mutable = Mutable() session.commit() model.mutable.nested_mutable.greet = 'hello world' session.commit() print(model.mutable.nested_mutable.greet) # nested mutable list and dict model.mutable = {} session.commit() model.mutable['greet'] = ['hello world'] session.commit() print(model.mutable) # storing database models model.mutable = model session.commit() print(model.mutable) # common literals model.mutable = 'hello world' session.commit() print(model.mutable) Out: hello world {'greet': ['hello world']} <__main__.MyModel object at 0x7fe54a2d7b00> hello world Citation @software{bowen2020sqlalchemy-mutable, author = {Dillon Bowen}, title = {SQLAlchemy-Mutable}, url = {https://dsbowen.github.io/sqlalchemy-mutable/}, date = {2020-10-16}, } License Users must cite this package in any publications which use it. It is licensed with the MIT License . Acknowledgments Original inspiration drawn from SQLAlchemy-JSON .","title":"Home"},{"location":"#sqlalchemy-mutable","text":"SQLAlchemy-Mutable aspires to be the most powerful and flexible SQLAlchemy database column type. Its features include: Nested mutation tracking Mutation tracking for list and dict Support for storing database models in mutable columns Support for common literals and datetime objects Support for custom mutable classes Support for converting existing classes to mutable classes Compatibility with Flask-SQLAlchemy","title":"SQLAlchemy-Mutable"},{"location":"#installation","text":"$ pip install sqlalchemy-mutable","title":"Installation"},{"location":"#quickstart","text":"Setup: from sqlalchemy_mutable import Mutable, MutableType, MutableModelBase, Query from sqlalchemy import create_engine, Column, Integer, String from sqlalchemy.orm import sessionmaker, scoped_session from sqlalchemy.ext.declarative import declarative_base # create a session (standard) engine = create_engine('sqlite:///:memory:') session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() Base = declarative_base() # subclass `MutableModelBase` when creating database models # which may be stored in a `Mutable` object class MyModel(MutableModelBase, Base): __tablename__ = 'mymodel' id = Column(Integer, primary_key=True) greeting = Column(String) # initialize a database column with `MutableType` mutable = Column(MutableType) # add a `query` class attribute initialized with a scoped_session # not necessary for use with Flask-SQLAlchemy query = Query(Session) def __init__(self): # set mutable column to `Mutable` object self.mutable = Mutable() # create the database (standard) Base.metadata.create_all(engine) Examples: model = MyModel() session.add(model) session.commit() # nested mutable objects model.mutable.nested_mutable = Mutable() session.commit() model.mutable.nested_mutable.greet = 'hello world' session.commit() print(model.mutable.nested_mutable.greet) # nested mutable list and dict model.mutable = {} session.commit() model.mutable['greet'] = ['hello world'] session.commit() print(model.mutable) # storing database models model.mutable = model session.commit() print(model.mutable) # common literals model.mutable = 'hello world' session.commit() print(model.mutable) Out: hello world {'greet': ['hello world']} <__main__.MyModel object at 0x7fe54a2d7b00> hello world","title":"Quickstart"},{"location":"#citation","text":"@software{bowen2020sqlalchemy-mutable, author = {Dillon Bowen}, title = {SQLAlchemy-Mutable}, url = {https://dsbowen.github.io/sqlalchemy-mutable/}, date = {2020-10-16}, }","title":"Citation"},{"location":"#license","text":"Users must cite this package in any publications which use it. It is licensed with the MIT License .","title":"License"},{"location":"#acknowledgments","text":"Original inspiration drawn from SQLAlchemy-JSON .","title":"Acknowledgments"},{"location":"basic/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Basic objects The basic objects of SQLAlchemy-Mutable are: MutableModelBase . Base class for database models with MutableType columns. MutableType . Column type associated with Mutable objects. Mutable . Generic mutable object which automatically tracks changes to its attributes and items. sqlalchemy_mutable. MutableModelBase Base class for database models with MutableType columns. This allows you to store and retrieve database models in MutableType columns. Examples Make sure you have run the setup code . model0 = MyModel() model1 = MyModel() session.add_all([model0, model1]) session.commit() model0.mutable = model1 # without subclassing `MutableModelBase`, # this would not retrieve `model1` model0.mutable Out: <__main__.MyModel at 0x7f6bd9936668> sqlalchemy_mutable. MutableType Column type associated with Mutable objects. MutableType database columns may be set to: Coerced types. SQLAlchemy-Mutable automatically coerces common objects such as int , str , and datetime . Mutable objects. SQLAlchemy-Mutable automatically converts list and dict to mutable objects. Database models. sqlalchemy_mutable. Mutable Base class for mutable objects. Mutable objects track changes to their 'children' (their attributes and items). Attributes: root : sqlalchemy_mutable.Mutable Root mutable object. Examples Make sure you have run the setup code . model = MyModel() session.add(model) model.mutable.nested_mutable = Mutable() session.commit() # if `MyModel.mutable` weren't a `MutableType` column, # this change would not survive a commit model.mutable.nested_mutable.greeting = 'hello world' session.commit() model.mutable.nested_mutable.greeting Out: 'hello, world!' Methods register_coerced_type ( cls, origin_type ) [source] Decorator for coerced type registration. When a MutableType column is set to an object of the origin type (i.e. when the coerce method is invoked), the object is first converted to a coerced type. Parameters: origin_type : class The origin class. Returns: register : callable Function to register an origin type. Notes This does not affect tracked items and attributes. That is, objects of origin types will not be coerced with the _convert method is invoked. Examples Make sure you have run the setup code . class MyClass(): def greet(self, name='world'): return 'hello, {}!'.format(name) @Mutable.register_coerced_type(MyClass) class CoercedMyClass(Mutable, MyClass): pass model = MyModel() # without registering an associated coerced type, # this will throw an error model.mutable = MyClass() model.mutable.greet() Out: 'hello, world!' register_tracked_type ( cls, origin_type ) [source] Decorator for tracked type registration. The origin_type maps to a tracked_type. Objects of origin types will be converted to objects of tracked types when the convert method is invoked. Conversion occurs automatically on coersion and when setting attributes and items. Parameters: origin_type : class The origin class. Returns: register : callable Function to register an origin type. Examples Make sure you have run the setup code . class MyClass(): def __init__(self, name): self.name = name def greet(self): return 'hello, {}!'.format(self.name) @Mutable.register_tracked_type(MyClass) class MutableMyClass(MyClass, Mutable): def __init__(self, source=None, root=None): ''' Parameters ---------- source : MyClass Original instance of `MyClass`. This will be converted into a `MutableMyClass` object. root : Mutable or None, default=None Root mutable object. This is handled by SQLAlchemy-Mutable. Set to `None` by default. ''' super().__init__(name=source.name) model = MyModel() session.add(model) model.mutable = Mutable() model.mutable.object = MyClass('world') session.commit() # without registering MyClass as a tracked type, # this change would not survive a commit model.mutable.object.name = 'moon' session.commit() model.mutable.object.greet() Out: 'hello, moon!'","title":"Basic objects"},{"location":"basic/#basic-objects","text":"The basic objects of SQLAlchemy-Mutable are: MutableModelBase . Base class for database models with MutableType columns. MutableType . Column type associated with Mutable objects. Mutable . Generic mutable object which automatically tracks changes to its attributes and items.","title":"Basic objects"},{"location":"basic/#sqlalchemy_mutablemutablemodelbase","text":"Base class for database models with MutableType columns. This allows you to store and retrieve database models in MutableType columns.","title":"sqlalchemy_mutable.MutableModelBase"},{"location":"basic/#examples","text":"Make sure you have run the setup code . model0 = MyModel() model1 = MyModel() session.add_all([model0, model1]) session.commit() model0.mutable = model1 # without subclassing `MutableModelBase`, # this would not retrieve `model1` model0.mutable Out: <__main__.MyModel at 0x7f6bd9936668>","title":"Examples"},{"location":"basic/#sqlalchemy_mutablemutabletype","text":"Column type associated with Mutable objects. MutableType database columns may be set to: Coerced types. SQLAlchemy-Mutable automatically coerces common objects such as int , str , and datetime . Mutable objects. SQLAlchemy-Mutable automatically converts list and dict to mutable objects. Database models.","title":"sqlalchemy_mutable.MutableType"},{"location":"basic/#sqlalchemy_mutablemutable","text":"Base class for mutable objects. Mutable objects track changes to their 'children' (their attributes and items). Attributes: root : sqlalchemy_mutable.Mutable Root mutable object.","title":"sqlalchemy_mutable.Mutable"},{"location":"basic/#examples_1","text":"Make sure you have run the setup code . model = MyModel() session.add(model) model.mutable.nested_mutable = Mutable() session.commit() # if `MyModel.mutable` weren't a `MutableType` column, # this change would not survive a commit model.mutable.nested_mutable.greeting = 'hello world' session.commit() model.mutable.nested_mutable.greeting Out: 'hello, world!'","title":"Examples"},{"location":"basic/#methods","text":"register_coerced_type ( cls, origin_type ) [source] Decorator for coerced type registration. When a MutableType column is set to an object of the origin type (i.e. when the coerce method is invoked), the object is first converted to a coerced type. Parameters: origin_type : class The origin class. Returns: register : callable Function to register an origin type.","title":"Methods"},{"location":"basic/#notes","text":"This does not affect tracked items and attributes. That is, objects of origin types will not be coerced with the _convert method is invoked.","title":"Notes"},{"location":"basic/#examples_2","text":"Make sure you have run the setup code . class MyClass(): def greet(self, name='world'): return 'hello, {}!'.format(name) @Mutable.register_coerced_type(MyClass) class CoercedMyClass(Mutable, MyClass): pass model = MyModel() # without registering an associated coerced type, # this will throw an error model.mutable = MyClass() model.mutable.greet() Out: 'hello, world!' register_tracked_type ( cls, origin_type ) [source] Decorator for tracked type registration. The origin_type maps to a tracked_type. Objects of origin types will be converted to objects of tracked types when the convert method is invoked. Conversion occurs automatically on coersion and when setting attributes and items. Parameters: origin_type : class The origin class. Returns: register : callable Function to register an origin type.","title":"Examples"},{"location":"basic/#examples_3","text":"Make sure you have run the setup code . class MyClass(): def __init__(self, name): self.name = name def greet(self): return 'hello, {}!'.format(self.name) @Mutable.register_tracked_type(MyClass) class MutableMyClass(MyClass, Mutable): def __init__(self, source=None, root=None): ''' Parameters ---------- source : MyClass Original instance of `MyClass`. This will be converted into a `MutableMyClass` object. root : Mutable or None, default=None Root mutable object. This is handled by SQLAlchemy-Mutable. Set to `None` by default. ''' super().__init__(name=source.name) model = MyModel() session.add(model) model.mutable = Mutable() model.mutable.object = MyClass('world') session.commit() # without registering MyClass as a tracked type, # this change would not survive a commit model.mutable.object.name = 'moon' session.commit() model.mutable.object.greet() Out: 'hello, moon!'","title":"Examples"},{"location":"changelog/","text":"Change log Version 0.0.9 Support for setting mutable column types to functions and partial functions Support for setting mutable column types to boolean values","title":"Change log"},{"location":"changelog/#change-log","text":"","title":"Change log"},{"location":"changelog/#version-009","text":"Support for setting mutable column types to functions and partial functions Support for setting mutable column types to boolean values","title":"Version 0.0.9"},{"location":"coerced_types/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Coerced types Coerced types allow Mutable objects to be set to a value of the subclassed type. Unlike tracked types, attributes and items of Mutable objects will not be converted to coerced types. Supported coerced types are: bool complex datetime.datetime float int str types.FunctionType Examples We begin with setup as follows. from sqlalchemy_mutable import Mutable, MutableType, MutableModelBase, Query from sqlalchemy import create_engine, Column, Integer, String from sqlalchemy.orm import sessionmaker, scoped_session from sqlalchemy.ext.declarative import declarative_base # create a session (standard) engine = create_engine('sqlite:///:memory:') session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() Base = declarative_base() # subclass `MutableModelBase` when creating database models # with `MutableType` columns class MyModel(MutableModelBase, Base): __tablename__ = 'mymodel' id = Column(Integer, primary_key=True) greeting = Column(String) # initialize a database column with `MutableType` mutable = Column(MutableType) # add a query class attribute initialized with a scoped_session # not necessary for use with Flask-SQLAlchemy query = Query(Session) def __init__(self): # set mutable column to `Mutable` object self.mutable = Mutable() # create the database (standard) Base.metadata.create_all(engine) String example. model = MyModel() model.mutable = 'hello world' model.mutable Out: 'hello world'","title":"Coerced types"},{"location":"coerced_types/#coerced-types","text":"Coerced types allow Mutable objects to be set to a value of the subclassed type. Unlike tracked types, attributes and items of Mutable objects will not be converted to coerced types. Supported coerced types are: bool complex datetime.datetime float int str types.FunctionType","title":"Coerced types"},{"location":"coerced_types/#examples","text":"We begin with setup as follows. from sqlalchemy_mutable import Mutable, MutableType, MutableModelBase, Query from sqlalchemy import create_engine, Column, Integer, String from sqlalchemy.orm import sessionmaker, scoped_session from sqlalchemy.ext.declarative import declarative_base # create a session (standard) engine = create_engine('sqlite:///:memory:') session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() Base = declarative_base() # subclass `MutableModelBase` when creating database models # with `MutableType` columns class MyModel(MutableModelBase, Base): __tablename__ = 'mymodel' id = Column(Integer, primary_key=True) greeting = Column(String) # initialize a database column with `MutableType` mutable = Column(MutableType) # add a query class attribute initialized with a scoped_session # not necessary for use with Flask-SQLAlchemy query = Query(Session) def __init__(self): # set mutable column to `Mutable` object self.mutable = Mutable() # create the database (standard) Base.metadata.create_all(engine) String example. model = MyModel() model.mutable = 'hello world' model.mutable Out: 'hello world'","title":"Examples"},{"location":"contribute/","text":"Contribute I welcome contributions to this project, including: Creating more coerced types. Creating more tracked types.","title":"Contribute"},{"location":"contribute/#contribute","text":"I welcome contributions to this project, including: Creating more coerced types. Creating more tracked types.","title":"Contribute"},{"location":"convert/","text":"Advanced type conversion Some types require more work to convert into mutable types. We illustrate advanced use by creating our own mutable list type. Make sure you have run the setup code . @Mutable.register_tracked_type(list) class MutableList(Mutable, list): def __init__(self, source=[], root=None): # 1. convert potentially mutable attributes/items to Mutable objects converted_list = self._convert_iterable(source) super().__init__(converted_list) # 2. classes with mutable items must have a `_tracked_items` attribute # `_tracked_items` is a list of potentially mutable items @property def _tracked_items(self): return list(self) # 3. call `self._changed()` to register change with the root Mutable object def append(self, item): self._changed() super().append(self._convert_item(item)) model = MyModel() model.mutable = [] session.add(model) session.commit() # without using a mutable list, this change would not survive a commit model.mutable.append('hello world') session.commit() model.mutable Out: ['hello world']","title":"Advanced type conversion"},{"location":"convert/#advanced-type-conversion","text":"Some types require more work to convert into mutable types. We illustrate advanced use by creating our own mutable list type. Make sure you have run the setup code . @Mutable.register_tracked_type(list) class MutableList(Mutable, list): def __init__(self, source=[], root=None): # 1. convert potentially mutable attributes/items to Mutable objects converted_list = self._convert_iterable(source) super().__init__(converted_list) # 2. classes with mutable items must have a `_tracked_items` attribute # `_tracked_items` is a list of potentially mutable items @property def _tracked_items(self): return list(self) # 3. call `self._changed()` to register change with the root Mutable object def append(self, item): self._changed() super().append(self._convert_item(item)) model = MyModel() model.mutable = [] session.add(model) session.commit() # without using a mutable list, this change would not survive a commit model.mutable.append('hello world') session.commit() model.mutable Out: ['hello world']","title":"Advanced type conversion"},{"location":"model_shell/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Storing models sqlalchemy_mutable.model_shell. Query class sqlalchemy_mutable.model_shell. Query ( scoped_session ) [source] Query attribute in database model. Models which have a query attribute will be unshelled automatically when stored and recovered in a Mutable object. See the setup code . Parameters: scoped_session : sqlalchemy.orm.scoping.scoped_session Current scoped session. Attributes: scoped_session : sqlalchemy.orm.scoping.scoped_session Set from the scoped_session parameter. sqlalchemy_mutable.model_shell. ModelShell class sqlalchemy_mutable.model_shell. ModelShell ( model ) [source] The ModelShell stores (shells) and recovers (unshells) database models in Mutable objects and MutableType columns. Parameters: model : sqlalchemy.ext.declarative.api.Base Database model to store. Attributes: id : usually int or str Identity of the model. model_class : class Class of the stored model. Notes The model must have an identity before it is shelled. i.e you must add it to the session and commit or flush it. Models are unshelled to make comparisons the __eq__ comparison. Examples Make sure you have run the setup code . from sqlalchemy_mutable.model_shell import ModelShell model = MyModel() session.add(model) session.commit() shell = ModelShell(model) shell.unshell() Out: <__main__.MyModel at 0x7f6bd9936c50> Methods unshell ( self ) [source] Recover (unshell) a model. Returns: model or (model_class, id) : If the original model has a query attribute, the orginal model is returned. Otherwise, a (model_class, id) tuple is returned which you can use to query the database to recover the model.","title":"Storing models"},{"location":"model_shell/#storing-models","text":"","title":"Storing models"},{"location":"model_shell/#sqlalchemy_mutablemodel_shellquery","text":"class sqlalchemy_mutable.model_shell. Query ( scoped_session ) [source] Query attribute in database model. Models which have a query attribute will be unshelled automatically when stored and recovered in a Mutable object. See the setup code . Parameters: scoped_session : sqlalchemy.orm.scoping.scoped_session Current scoped session. Attributes: scoped_session : sqlalchemy.orm.scoping.scoped_session Set from the scoped_session parameter.","title":"sqlalchemy_mutable.model_shell.Query"},{"location":"model_shell/#sqlalchemy_mutablemodel_shellmodelshell","text":"class sqlalchemy_mutable.model_shell. ModelShell ( model ) [source] The ModelShell stores (shells) and recovers (unshells) database models in Mutable objects and MutableType columns. Parameters: model : sqlalchemy.ext.declarative.api.Base Database model to store. Attributes: id : usually int or str Identity of the model. model_class : class Class of the stored model.","title":"sqlalchemy_mutable.model_shell.ModelShell"},{"location":"model_shell/#notes","text":"The model must have an identity before it is shelled. i.e you must add it to the session and commit or flush it. Models are unshelled to make comparisons the __eq__ comparison.","title":"Notes"},{"location":"model_shell/#examples","text":"Make sure you have run the setup code . from sqlalchemy_mutable.model_shell import ModelShell model = MyModel() session.add(model) session.commit() shell = ModelShell(model) shell.unshell() Out: <__main__.MyModel at 0x7f6bd9936c50>","title":"Examples"},{"location":"model_shell/#methods","text":"unshell ( self ) [source] Recover (unshell) a model. Returns: model or (model_class, id) : If the original model has a query attribute, the orginal model is returned. Otherwise, a (model_class, id) tuple is returned which you can use to query the database to recover the model.","title":"Methods"},{"location":"mutable_dict/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Mutable dictionary Examples Make sure you have run the setup code . model = MyModel() model.mutable = {} session.add(model) session.commit() # without a mutable dictionary, # this change will not survive a commit model.mutable['hello'] = 'world' session.commit() model.mutable Out: {'hello': 'world'} sqlalchemy_mutable. MutableDictType Mutable dictionary database type. In the setup code, we use a MutableType database column, which handles dictionaries as well as other objects. To force the column to be a dictionary, substitute MutableDictType for MutableType . sqlalchemy_mutable. MutableDict class sqlalchemy_mutable. MutableDict ( source={}, root=None ) [source] Subclasses dict , and implements all dict methods. Parameters: source : dict, default={} Source object which will be converted into a mutable dictionary. root : sqlalchemy_mutable.Mutable or None, default=None Root mutable object. If None , self is assumed to be the root. Methods unshell ( self ) [source] Call to force values to unshell. Normally this occurs automatically. Returns: copy : dict Shallow copy of self where all ModelShell values are unshelled.","title":"Mutable dictionary"},{"location":"mutable_dict/#mutable-dictionary","text":"","title":"Mutable dictionary"},{"location":"mutable_dict/#examples","text":"Make sure you have run the setup code . model = MyModel() model.mutable = {} session.add(model) session.commit() # without a mutable dictionary, # this change will not survive a commit model.mutable['hello'] = 'world' session.commit() model.mutable Out: {'hello': 'world'}","title":"Examples"},{"location":"mutable_dict/#sqlalchemy_mutablemutabledicttype","text":"Mutable dictionary database type. In the setup code, we use a MutableType database column, which handles dictionaries as well as other objects. To force the column to be a dictionary, substitute MutableDictType for MutableType .","title":"sqlalchemy_mutable.MutableDictType"},{"location":"mutable_dict/#sqlalchemy_mutablemutabledict","text":"class sqlalchemy_mutable. MutableDict ( source={}, root=None ) [source] Subclasses dict , and implements all dict methods. Parameters: source : dict, default={} Source object which will be converted into a mutable dictionary. root : sqlalchemy_mutable.Mutable or None, default=None Root mutable object. If None , self is assumed to be the root.","title":"sqlalchemy_mutable.MutableDict"},{"location":"mutable_dict/#methods","text":"unshell ( self ) [source] Call to force values to unshell. Normally this occurs automatically. Returns: copy : dict Shallow copy of self where all ModelShell values are unshelled.","title":"Methods"},{"location":"mutable_list/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Mutable list Examples Make sure you have run the setup code . model = MyModel() model.mutable = [] session.add(model) session.commit() # without a mutable list, # this change will not survive a commit model.mutable.append('hello world') session.commit() model.mutable Out: ['hello world'] sqlalchemy_mutable. MutableListType Mutable list database type. In the setup code, we use a MutableType database column, which handles lists as well as other objects. To force the column to be a list, substitute MutableListType for MutableType . sqlalchemy_mutable. MutableList class sqlalchemy_mutable. MutableList ( source=[], root=None ) [source] Subclasses list , and implements all list methods. Parameters: source : list, default=[] Source objects which will be converted into a mutable list. root : sqlalchemy.Mutable or None, default=None Root mutable object. If None , self is assumed to be the root. Methods unshell ( self ) [source] Call to force values to unshell. Normally this occurs automatically. Returns: copy : list Shallow copy of self where all ModelShell items are unshelled.","title":"Mutable list"},{"location":"mutable_list/#mutable-list","text":"","title":"Mutable list"},{"location":"mutable_list/#examples","text":"Make sure you have run the setup code . model = MyModel() model.mutable = [] session.add(model) session.commit() # without a mutable list, # this change will not survive a commit model.mutable.append('hello world') session.commit() model.mutable Out: ['hello world']","title":"Examples"},{"location":"mutable_list/#sqlalchemy_mutablemutablelisttype","text":"Mutable list database type. In the setup code, we use a MutableType database column, which handles lists as well as other objects. To force the column to be a list, substitute MutableListType for MutableType .","title":"sqlalchemy_mutable.MutableListType"},{"location":"mutable_list/#sqlalchemy_mutablemutablelist","text":"class sqlalchemy_mutable. MutableList ( source=[], root=None ) [source] Subclasses list , and implements all list methods. Parameters: source : list, default=[] Source objects which will be converted into a mutable list. root : sqlalchemy.Mutable or None, default=None Root mutable object. If None , self is assumed to be the root.","title":"sqlalchemy_mutable.MutableList"},{"location":"mutable_list/#methods","text":"unshell ( self ) [source] Call to force values to unshell. Normally this occurs automatically. Returns: copy : list Shallow copy of self where all ModelShell items are unshelled.","title":"Methods"},{"location":"mutable_partial/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Mutable partial This is analogous to functools.partial . Examples Make sure you have run the setup code . def foo(*args, **kwargs): print('args', args) print('kwargs', kwargs) return 0 model = MyModel() model.mutable = partial(foo, 'hello world', goodbye='moon') model.mutable() Out: args ('hello world',) kwargs {'goodbye': 'moon'} 0 sqlalchemy_mutable. partial class sqlalchemy_mutable. partial ( func, *args, **kwargs ) [source] Methods register ( cls, func ) [source] Register a partial function. Parameters: func : callable Returns: func : callable func parameter. Examples Make sure you have run the setup code. @partial.register def foo(*args, **kwargs): print('args', args) print('kwargs', kwargs) return 0 model = MyModel() model.mutable = partial.foo('hello world', goodbye='moon') model.mutable()","title":"Mutable partial function"},{"location":"mutable_partial/#mutable-partial","text":"This is analogous to functools.partial .","title":"Mutable partial"},{"location":"mutable_partial/#examples","text":"Make sure you have run the setup code . def foo(*args, **kwargs): print('args', args) print('kwargs', kwargs) return 0 model = MyModel() model.mutable = partial(foo, 'hello world', goodbye='moon') model.mutable() Out: args ('hello world',) kwargs {'goodbye': 'moon'} 0","title":"Examples"},{"location":"mutable_partial/#sqlalchemy_mutablepartial","text":"class sqlalchemy_mutable. partial ( func, *args, **kwargs ) [source]","title":"sqlalchemy_mutable.partial"},{"location":"mutable_partial/#methods","text":"register ( cls, func ) [source] Register a partial function. Parameters: func : callable Returns: func : callable func parameter.","title":"Methods"},{"location":"mutable_partial/#examples_1","text":"Make sure you have run the setup code. @partial.register def foo(*args, **kwargs): print('args', args) print('kwargs', kwargs) return 0 model = MyModel() model.mutable = partial.foo('hello world', goodbye='moon') model.mutable()","title":"Examples"},{"location":"setup/","text":"Setup All examples in the documentation assume you have run the following setup code for SQLAlchemy or Flask-SQLAlchemy . SQLAlchemy from sqlalchemy_mutable import Mutable, MutableType, MutableModelBase, Query from sqlalchemy import create_engine, Column, Integer, String from sqlalchemy.orm import sessionmaker, scoped_session from sqlalchemy.ext.declarative import declarative_base # create a session (standard) engine = create_engine('sqlite:///:memory:') session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() Base = declarative_base() # subclass `MutableModelBase` when creating database models # which may be stored in a `Mutable` object class MyModel(MutableModelBase, Base): __tablename__ = 'mymodel' id = Column(Integer, primary_key=True) greeting = Column(String) # initialize a database column with `MutableType` mutable = Column(MutableType) # add a `query` class attribute initialized with a scoped_session # not necessary for use with Flask-SQLAlchemy query = Query(Session) def __init__(self): # set mutable column to `Mutable` object self.mutable = Mutable() # create the database (standard) Base.metadata.create_all(engine) Flask-SQLAlchemy from sqlalchemy_mutable import Mutable, MutableType, MutableModelBase from flask import Flask from flask_sqlalchemy import SQLAlchemy # create a session (standard) app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:' app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False db = SQLAlchemy(app) # subclass `MutableModelBase` when creating database models class MyModel(MutableModelBase, db.Model): id = db.Column(db.Integer, primary_key=True) greeting = db.Column(db.String) # initialize a database column with `MutableType` mutable = db.Column(MutableType) def __init__(self): # set mutable column to `Mutable` object self.mutable = Mutable() # create the database (standard) db.create_all() session = db.session","title":"Setup"},{"location":"setup/#setup","text":"All examples in the documentation assume you have run the following setup code for SQLAlchemy or Flask-SQLAlchemy .","title":"Setup"},{"location":"setup/#sqlalchemy","text":"from sqlalchemy_mutable import Mutable, MutableType, MutableModelBase, Query from sqlalchemy import create_engine, Column, Integer, String from sqlalchemy.orm import sessionmaker, scoped_session from sqlalchemy.ext.declarative import declarative_base # create a session (standard) engine = create_engine('sqlite:///:memory:') session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() Base = declarative_base() # subclass `MutableModelBase` when creating database models # which may be stored in a `Mutable` object class MyModel(MutableModelBase, Base): __tablename__ = 'mymodel' id = Column(Integer, primary_key=True) greeting = Column(String) # initialize a database column with `MutableType` mutable = Column(MutableType) # add a `query` class attribute initialized with a scoped_session # not necessary for use with Flask-SQLAlchemy query = Query(Session) def __init__(self): # set mutable column to `Mutable` object self.mutable = Mutable() # create the database (standard) Base.metadata.create_all(engine)","title":"SQLAlchemy"},{"location":"setup/#flask-sqlalchemy","text":"from sqlalchemy_mutable import Mutable, MutableType, MutableModelBase from flask import Flask from flask_sqlalchemy import SQLAlchemy # create a session (standard) app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:' app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False db = SQLAlchemy(app) # subclass `MutableModelBase` when creating database models class MyModel(MutableModelBase, db.Model): id = db.Column(db.Integer, primary_key=True) greeting = db.Column(db.String) # initialize a database column with `MutableType` mutable = db.Column(MutableType) def __init__(self): # set mutable column to `Mutable` object self.mutable = Mutable() # create the database (standard) db.create_all() session = db.session","title":"Flask-SQLAlchemy"}]}